package generators;

import java.util.List;
import java.util.Random;

import ctwedge.ctWedge.AndExpression;
import ctwedge.ctWedge.AtomicPredicate;
import ctwedge.ctWedge.Constraint;
import ctwedge.ctWedge.CtWedgeFactory;
import ctwedge.ctWedge.EqualExpression;
import ctwedge.ctWedge.Expression;
import ctwedge.ctWedge.NotExpression;
import ctwedge.ctWedge.Operators;
import ctwedge.ctWedge.Parameter;
import ctwedge.ctWedge.impl.CtWedgeFactoryImpl;
import ctwedge.util.ParameterElementsGetterAsStrings;
import models.Model;

/**
 * Generates a new model with constraints, and with parameters of the category
 * given as parameter. The constraints are expressed as Forbidden Tuples
 * 
 * 
 * @author andrea
 *
 */
public class WithConstraintGeneratorFT extends WithoutConstraintGenerator implements GeneratorWithConstraintsInterface {

	/**
	 * Generate an IPM
	 * 
	 * @param type   the type of models to be generated (with booleans, with
	 *               enumeratives, with integers, ...)
	 * @param config the generator configuration used for generating the model
	 * @return the generated IPM
	 */
	@Override
	public Model generate(Category type, GeneratorConfiguration config) {
		// Compile the model with the parameters and not the constraints
		Model m = super.generate(type, config);
		m.setGeneratorConfiguration(config);

		// Add the constraints
		int nConstraint = Randomizer.generate(m.getGeneratorConfiguration().N_CONSTRAINTS_MIN,
				m.getGeneratorConfiguration().N_CONSTRAINTS_MAX);
		for (int i = 0; i < nConstraint; i++) {
			Constraint c;

			// Considering MFTs, the constraints can be of two different types
			// 1. NOT (A = A1 AND B = B2 AND ...)
			// 2. A!=A1 or B!=B2 ...
			// Thus, a recursive approach is not suitable in this case, but we will focus on
			// the first one, snce the second is also a CNF, which is generated by another
			// generator

			// Extract the complexity of the constraint (i.e., the number of parameters
			// included)
			int complexity = Randomizer.generate(m.getGeneratorConfiguration().MIN_CONSTRAINTS_COMPLEXITY,
					m.getGeneratorConfiguration().MAX_CONSTRAINTS_COMPLEXITY);

			c = generateConstraintFromComplexity(m, complexity);

			// Add the constraint
			m.addConstraint(c);
		}

		return m;
	}

	/**
	 * Generates a constraint with a given complexity in CNF form
	 * 
	 * @param m          the model being populated
	 * @param complexity the constraint complexity
	 * @return the constraint
	 */
	public Expression generateConstraintFromComplexity(Model m, int complexity) {
		CtWedgeFactory factory = new CtWedgeFactoryImpl();
		Expression c;
		// First solution
		c = factory.createNotExpression();
		Expression andExp;
		if (complexity > 1)
			andExp = factory.createAndExpression();
		else
			andExp = factory.createEqualExpression();
		Expression exp = andExp;
		for (int j = 0; j < complexity; j++) {
			// Parameter of the equal expression
			Parameter p = m.getRandomParamenter();
			EqualExpression eq = factory.createEqualExpression();
			eq.setOp(Operators.EQ);
			
			AtomicPredicate left = factory.createAtomicPredicate();
			left.setName(p.getName());
			eq.setLeft(left);
			
			AtomicPredicate right = factory.createAtomicPredicate();
			if (Randomizer.generate(0, 1) == 0 || !m.getGeneratorConfiguration().USE_CONSTRAINTS_BETWEEN_PARAMETERS) {
				List<String> parameterValues = ParameterElementsGetterAsStrings.instance.caseParameter(p);
				String value = parameterValues.get(new Random().nextInt(0, parameterValues.size()));
				right.setName(value);
			} else {
				right.setName(m.getRandomParamenterOfClass(p).getName());
			}
			eq.setRight(right);
			
			if(j == complexity - 1) {
				if (complexity == 1)
					andExp = eq;
				else
					((AndExpression)(exp.eContainer())).setRight(eq);
			} else {			
				((AndExpression)exp).setLeft(eq);
				((AndExpression)exp).setRight(factory.createAndExpression());
				exp = ((AndExpression)exp).getRight();
			}
		}
		// Set the constraint
		((NotExpression) c).setPredicate(andExp);
		return c;
	}
}
